"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1615],{4137:function(n,e,t){t.d(e,{Zo:function(){return s},kt:function(){return _}});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function d(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=r.createContext({}),o=function(n){var e=r.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):c(c({},e),n)),t},s=function(n){var e=o(n.components);return r.createElement(l.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,l=n.parentName,s=d(n,["components","mdxType","originalType","parentName"]),u=o(t),_=a,f=u["".concat(l,".").concat(_)]||u[_]||p[_]||i;return t?r.createElement(f,c(c({ref:e},s),{},{components:t})):r.createElement(f,c({ref:e},s))}));function _(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,c=new Array(i);c[0]=u;var d={};for(var l in e)hasOwnProperty.call(e,l)&&(d[l]=e[l]);d.originalType=n,d.mdxType="string"==typeof n?n:a,c[1]=d;for(var o=2;o<i;o++)c[o]=t[o];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1318:function(n,e,t){t.r(e),t.d(e,{assets:function(){return s},contentTitle:function(){return l},default:function(){return _},frontMatter:function(){return d},metadata:function(){return o},toc:function(){return p}});var r=t(7462),a=t(3366),i=(t(7294),t(4137)),c=["components"],d={id:"tcp_ip-9_1",title:"\u901a\u4fe1\u5b9e\u73b0--Linux\u7684TCP&UDP\u534f\u8bae\u4f7f\u7528\u903b\u8f91\u53ca\u6e90\u7801",date:new Date("2021-11-17T00:00:00.000Z"),authors:"\u9cb8\u8bed",tags:["\u534f\u8bae","tcp/ip","UDP","TCP","Linux"]},l=void 0,o={unversionedId:"skill/protocol/tcp_ip/tcp_ip-9_1",id:"skill/protocol/tcp_ip/tcp_ip-9_1",title:"\u901a\u4fe1\u5b9e\u73b0--Linux\u7684TCP&UDP\u534f\u8bae\u4f7f\u7528\u903b\u8f91\u53ca\u6e90\u7801",description:"Linux TCP&UDP\u534f\u8bae \u5b9e\u73b0\u6e90\u7801 \u6d41\u7a0b\u56fe",source:"@site/docs\\skill\\protocol\\tcp_ip\\9_1_\u901a\u4fe1\u5b9e\u73b0--Linux\u7684TCP&UDP\u534f\u8bae\u4f7f\u7528\u903b\u8f91\u53ca\u6e90\u7801.md",sourceDirName:"skill/protocol/tcp_ip",slug:"/skill/protocol/tcp_ip/tcp_ip-9_1",permalink:"/docs/skill/protocol/tcp_ip/tcp_ip-9_1",draft:!1,tags:[{label:"\u534f\u8bae",permalink:"/docs/tags/\u534f\u8bae"},{label:"tcp/ip",permalink:"/docs/tags/tcp-ip"},{label:"UDP",permalink:"/docs/tags/udp"},{label:"TCP",permalink:"/docs/tags/tcp"},{label:"Linux",permalink:"/docs/tags/linux"}],version:"current",frontMatter:{id:"tcp_ip-9_1",title:"\u901a\u4fe1\u5b9e\u73b0--Linux\u7684TCP&UDP\u534f\u8bae\u4f7f\u7528\u903b\u8f91\u53ca\u6e90\u7801",date:"2021-11-17T00:00:00.000Z",authors:"\u9cb8\u8bed",tags:["\u534f\u8bae","tcp/ip","UDP","TCP","Linux"]},sidebar:"skill",previous:{title:"\u534f\u8bae\u5206\u6790--Wireshark & TCP\u7684\u53cc\u7aef\u6570\u636e\u5305\u5206\u6790",permalink:"/docs/skill/protocol/tcp_ip/tcp_ip-2_1"},next:{title:"Arm",permalink:"/docs/category/arm"}},s={},p=[{value:"UDP",id:"udp",level:2},{value:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe",id:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe",level:3},{value:"\u51fd\u6570\u53ca\u4f5c\u7528",id:"\u51fd\u6570\u53ca\u4f5c\u7528",level:4},{value:"\u6e90\u7801",id:"\u6e90\u7801",level:3},{value:"udp_client.c",id:"udp_clientc",level:4},{value:"udp_server.c",id:"udp_serverc",level:4},{value:"TCP",id:"tcp",level:2},{value:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe",id:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe-1",level:3},{value:"\u51fd\u6570\u53ca\u4f5c\u7528",id:"\u51fd\u6570\u53ca\u4f5c\u7528-1",level:4},{value:"\u6e90\u7801",id:"\u6e90\u7801-1",level:3},{value:"tcp_client.c",id:"tcp_clientc",level:4},{value:"tcp_server.c",id:"tcp_serverc",level:4},{value:"\u7ed3\u8bed",id:"\u7ed3\u8bed",level:2}],u={toc:p};function _(n){var e=n.components,t=(0,a.Z)(n,c);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Linux TCP&UDP\u534f\u8bae \u5b9e\u73b0\u6e90\u7801 \u6d41\u7a0b\u56fe"),(0,i.kt)("h2",{id:"udp"},"UDP"),(0,i.kt)("h3",{id:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe"},"\u7a0b\u5e8f\u6d41\u7a0b\u56fe"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img-blog.csdnimg.cn/5ffb4e0af8fa4883985f6107e28ed52a.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq6Ze7wrflubvop4k=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"UDP\u7a0b\u5e8f\u6d41\u56fe"})),(0,i.kt)("h4",{id:"\u51fd\u6570\u53ca\u4f5c\u7528"},"\u51fd\u6570\u53ca\u4f5c\u7528"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"\u51fd\u6570\u540d"),(0,i.kt)("th",{parentName:"tr",align:null},"\u529f\u80fd"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"socket()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u521b\u5efa\u5957\u63a5\u5b57")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bind()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u7ed1\u5b9a ip + \u5957\u63a5\u5b57")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"recvfrom()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u63a5\u6536\u6d88\u606f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sendto()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u53d1\u9001\u6d88\u606f")))),(0,i.kt)("h3",{id:"\u6e90\u7801"},"\u6e90\u7801"),(0,i.kt)("h4",{id:"udp_clientc"},"udp_client.c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/** \n * @berief: \u4e3b\u51fd\u6570,\u5efa\u7acbudp_client.c\n * @param:   argc    \u7b2c\u51e0\u4e2a\u53c2\u6570\n * @param:   *arrgv[]    \u53c2\u6570\n * @rote:   \u53c2\u6570\u53ef\u4ee5\u4f7f\u7528\u4e5f\u53ef\u4ee5\u4e0d\u4f7f\u7528\n * @return: 0\n */\nint main(int argc, char *argv[])\n{\n    int sockfd = 0;\n    struct sockaddr_in dest_addr;\n    unsigned short port = 8000;\n    char *server_ip = "172.20.223.151";\n    \n    if( argc > 1 )  //\u7b2c\u4e00\u4e2a\u53c2\u6570\u6539ip\n    {       \n        server_ip = argv[1];\n    }   \n    \n    if( argc > 2 )  //\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6539\u7aef\u53e3\n    {\n        port = atoi(argv[2]);\n    }\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);  //\u521b\u5efa\u5957\u63a5\u5b57 SOCK_DGRAM \u6570\u636e\u62a5\u5957\u63a5\u5b57\u7c7b\u578b\n    if(sockfd < 0)\n    {\n        perror("socket error!");\n        exit(-1);\n    }\n    \n    bzero(&dest_addr, sizeof(dest_addr));\n    dest_addr.sin_family = AF_INET;\n    dest_addr.sin_port   = htons(port);\n    inet_pton(AF_INET, server_ip, &dest_addr.sin_addr);\n\n    printf("ready send data to UDP server %s:%d!\\n", server_ip, port);\n    \n    while(1)\n    {\n        char send_buf[512] = "";\n        char recv_buf[512] = "";\n        \n        fgets(send_buf, sizeof(send_buf), stdin);\n        send_buf[strlen(send_buf)-1] = \'\\0\';\n        \n        sendto(sockfd, send_buf, strlen(send_buf), 0, (struct sockaddr*)&dest_addr, sizeof(dest_addr));\n        \n        recvfrom(sockfd, recv_buf, sizeof(recv_buf), 0, NULL, NULL);  //\u63a5\u6536\u6d88\u606f\n        printf("%s\\n", recv_buf);\n    }\n    \n    close(sockfd);\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"udp_serverc"},"udp_server.c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n\n/** \n * @berief: \u4e3b\u51fd\u6570,\u5efa\u7acbudp_server.c\n * @param:   argc    \u7b2c\u51e0\u4e2a\u53c2\u6570\n * @param:   *arrgv[]    \u53c2\u6570\n * @rote:   \u53c2\u6570\u53ef\u4ee5\u4f7f\u7528\u4e5f\u53ef\u4ee5\u4e0d\u4f7f\u7528\n * @return: 0\n */\nint main(int argc, char *argv[])\n{\n    int sockfd = 0;\n    int err_log = 0;\n    struct sockaddr_in my_addr;\n    unsigned short port = 8000;\n\n    if(argc > 1)\n    {\n        port = atoi(argv[1]);\n    }\n\n    printf("UDP Server Started!\\n");\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if(sockfd < 0)\n    {\n        perror("socket");\n        exit(-1);\n    }\n    \n    bzero(&my_addr, sizeof(my_addr));\n    my_addr.sin_family = AF_INET;\n    my_addr.sin_port   = htons(port);\n    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    printf("Binding server to port %d\\n", port);\n    \n    err_log = bind(sockfd, (struct sockaddr*)&my_addr, sizeof(my_addr));\n    if(err_log != 0)\n    {\n        perror("bind");\n        close(sockfd);      \n        exit(-1);\n    }\n    \n    printf("waiting data from other client...\\n");\n    while(1)\n    {\n        char recv_buf[512] = "";\n        char cli_ip[INET_ADDRSTRLEN] = "";\n        int recv_len = 0;\n        struct sockaddr_in client_addr;\n        socklen_t cliaddr_len = sizeof(client_addr);\n        \n        recv_len = recvfrom(sockfd, recv_buf, sizeof(recv_buf), 0, (struct sockaddr*)&client_addr, &cliaddr_len);\n        printf("client ip = %s\\n", inet_ntop(AF_INET, &client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN));\n        sendto(sockfd, recv_buf, recv_len, 0, (struct sockaddr*)&client_addr, cliaddr_len);\n    }\n    \n    close(sockfd);\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"tcp"},"TCP"),(0,i.kt)("h3",{id:"\u7a0b\u5e8f\u6d41\u7a0b\u56fe-1"},"\u7a0b\u5e8f\u6d41\u7a0b\u56fe"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img-blog.csdnimg.cn/774c7fc90e764791a88cb5cb63cc73d5.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pyq6Ze7wrflubvop4k=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"tcp\u7a0b\u5e8f\u6d41\u7a0b"})),(0,i.kt)("h4",{id:"\u51fd\u6570\u53ca\u4f5c\u7528-1"},"\u51fd\u6570\u53ca\u4f5c\u7528"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"\u51fd\u6570\u540d"),(0,i.kt)("th",{parentName:"tr",align:null},"\u529f\u80fd"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"socket()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u521b\u5efa\u5957\u63a5\u5b57")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bind()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5957\u63a5\u5b57",(0,i.kt)("strong",{parentName:"td"},"\u7ed1\u5b9a"),"\u7aef\u53e3 + IP")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"listen()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u76d1\u542c\u7aef\u53e3\u53f7\u662f\u5426\u6709\u8fde\u63a5,\u7b49\u5f85\u5efa\u7acb")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"accept()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u8c03\u53d6\u5217\u8868\u4e2d\u5df2\u5efa\u7acb\u7684\u8fde\u63a5")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"write()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5199")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"read()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u8bfb")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"close()"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5173\u95ed\u6587\u4ef6\u6807\u8bc6\u7b26")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"accept()"),(0,i.kt)("td",{parentName:"tr",align:null},"client \u7684\u5957\u63a5\u5b57\u8fde\u63a5 Server \u7684\u5957\u63a5\u5b57")))),(0,i.kt)("h3",{id:"\u6e90\u7801-1"},"\u6e90\u7801"),(0,i.kt)("h4",{id:"tcp_clientc"},"tcp_client.c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n/** \n * @berief: \u4e3b\u51fd\u6570,\u5efa\u7acbtcp_client.c\n * @param:   argc    \u7b2c\u51e0\u4e2a\u53c2\u6570\n * @param:   *arrgv[]    \u53c2\u6570\n * @rote:   \u53c2\u6570\u53ef\u4ee5\u4f7f\u7528\u4e5f\u53ef\u4ee5\u4e0d\u4f7f\u7528\n * @return: 0\n */\nint main(int argc, char *argv[])\n{\n    // while (1)\n    // {    \n        unsigned short port = 8080;  //\u7aef\u53e3\u53f7\n        char *server_ip = "192.168.20.61";  //\u670d\u52a1\u5668ip\n        char send_buf[512] = "A";\n        char recv_buf[512] = "";\n        int sockfd = 0;  //\u5957\u63a5\u5b57\u6587\u4ef6\u6807\u8bc6\u7b26\n        int err_log = 0;  //\u9519\u8bef\u8fd4\u56de\n        struct sockaddr_in server_addr;  //tcp\u901a\u4fe1\u4e2d\u670d\u52a1\u5668\u5730\u5740\u7ed3\u6784\u4f53\n\n        if(argc > 1)\n        {\n            server_ip = argv[1];\n        }\n\n        if (argc > 2)\n        {\n            port = atoi(argv[2]);  //char --\x3e int\n        }\n\n        //\u521d\u59cb\u5316\u670d\u52a1\u5668\u5730\u5740\n        bzero(&server_addr,sizeof(server_addr));  //\u5c06\u5730\u5740\u7684\u6570\u636e\u957f\u6e05\u96f6\n        server_addr.sin_family = AF_INET;  //tcp udp\n        server_addr.sin_port = htons(port);  \n        /*\n            htons(unsigned short k)\n            \u65e0\u7b26\u53f7\u77ed\u6574\u578b\u6570\u503c --\x3e \u7f51\u7edc\u5b57\u8282\u5e8f\n            \u5927\u7aef\u6a21\u5f0f--\u9ad8\u5b57\u8282\u5b58\u653e\u5728\u5185\u5b58\u7684\u4f4e\u5730\u5740\u5904\n            --port == 0x1234\n            ----\u5185\u5b58\u4e2d       addr    addr+1  \n                            0x12    0x34\n            ----\u7f51\u7edc\u5b57\u8282\u5e8f  0x34    0x12\n        */\n        inet_pton(AF_INET, server_ip, &server_addr.sin_addr); //\u5c06\u5730\u5740\u7684\u70b9\u5206\u5341\u8fdb\u5236\u8f6c\u6362\u4e3a2\u8fdb\u5236\n\n        //\u521b\u5efa\u901a\u4fe1\u7aef\u70b9--\u5957\u63a5\u5b57\n        sockfd = socket(AF_INET,SOCK_STREAM,0);\n        if(sockfd < 0)\n        {\n            perror("socket");\n            exit(-1);\n        }\n\n        //\u94fe\u63a5\u670d\u52a1\u5668\n        err_log = connect(sockfd,(struct sockaddr*)&server_addr,sizeof(server_addr));\n        if(err_log != 0)\n        {\n            perror("connect");\n            close(sockfd);\n            exit(-1);\n        }\n\n        //\u901a\u4fe1\n        send(sockfd, send_buf, strlen(send_buf), 0);   // \u5411\u670d\u52a1\u5668\u53d1\u9001\u4fe1\u606f\n        recv(sockfd, recv_buf, sizeof(recv_buf), 0);   // \u63a5\u6536\u670d\u52a1\u5668\u53d1\u56de\u7684\u4fe1\u606f\n        printf("%s\\n", recv_buf);\n        \n        //\u7ed3\u675f\u901a\u4fe1,\u5173\u95ed\u5957\u63a5\u5b57\u6587\u4ef6\u6807\u8bc6\n        close(sockfd);\n\n        // sleep(5);\n    // }\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"tcp_serverc"},"tcp_server.c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/** \n * @berief: \u4e3b\u51fd\u6570,\u5efa\u7acbtcp_server.c\n * @param:   argc    \u7b2c\u51e0\u4e2a\u53c2\u6570\n * @param:   *arrgv[]    \u53c2\u6570\n * @rote:   \u53c2\u6570\u53ef\u4ee5\u4f7f\u7528\u4e5f\u53ef\u4ee5\u4e0d\u4f7f\u7528\n * @return: 0\n */\nint main(int argc, char *argv[])\n{\n    char recv_buf[2048] = "";  //\u63a5\u6536\u7f13\u5b58\u533a\n    int sockfd = 0;  //\u901a\u4fe1\u4f7f\u7528\u7684\u5957\u63a5\u5b57\u6587\u4ef6\u6807\u8bc6\u7b26\n    int connfd = 0;\n    int err_log = 0;\n    struct sockaddr_in my_addr;\n    unsigned short port = 80000;  //\u76d1\u542c\u7aef\u53e3\u53f7\n\n    //\u53ef\u4ee5\u4fee\u6539\u7aef\u53e3\u53f7\n    if(argc > 1)\n    {\n        port = atoi(argv[1]);\n    }\n    printf("TCP Server Started at port %d\\n",port);\n\n    //\u521b\u5efa\u901a\u4fe1\u4e2d\u5957\u63a5\u5b57\u6587\u4ef6\u6807\u8bc6\u7b26\n    sockfd = socket(AF_INET,SOCK_STREAM,0);\n    if(sockfd < 0)\n    {\n        perror("socket");\n        exit(-1);\n    }\n\n    //\u521d\u59cb\u5316\u670d\u52a1\u5668\u5730\u5740\n    bzero(&my_addr, sizeof(my_addr));  //\u5730\u5740\u6e05\u96f6  \n    my_addr.sin_family = AF_INET;  //\u9009\u62e9TCP/UDP\u6a21\u5f0f\n    my_addr.sin_port   = htons(port);\n    /*\n        htons(unsigned short k)\n        \u65e0\u7b26\u53f7\u77ed\u6574\u578b\u6570\u503c --\x3e \u7f51\u7edc\u5b57\u8282\u5e8f\n        \u5927\u7aef\u6a21\u5f0f--\u9ad8\u5b57\u8282\u5b58\u653e\u5728\u5185\u5b58\u7684\u4f4e\u5730\u5740\u5904\n        --port == 0x1234\n        ----\u5185\u5b58\u4e2d       addr    addr+1  \n                        0x12    0x34\n        ----\u7f51\u7edc\u5b57\u8282\u5e8f  0x34    0x12\n    */\n    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //\u5c06\u5730\u5740\u768432\u4f4d\u65e0\u7b26\u53f7\u957f\u6574\u5f62\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\n\n    //\u5957\u63a5\u5b57\u4e0e\u7aef\u53e3\u548c\u5730\u5740\u7684\u7ed1\u5b9a\n    printf("Binding server to port %d\\n", port);\n    err_log = bind(sockfd, (struct sockaddr*)&my_addr, sizeof(my_addr));\n    /** \n     * bind()\n     * \u5bf9\u5957\u63a5\u5b57-\u5730\u5740-\u7aef\u53e3\u7ed1\u5b9a\n    */\n    if( err_log != 0)\n    {\n        perror("binding");\n        close(sockfd);      \n        exit(-1);\n    }\n    err_log = listen(sockfd, 10);  //\u5957\u63a5\u5b57\u662f\u5426\u6765\u8fde\u63a5\n    /** \n     * \u53c2\u6570\u4e00   \u5957\u63a5\u5b57\n     * \u53c2\u6570\u4e8c   \u8bf7\u6c42\u961f\u5217\u4e2d\u53ef\u4ee5\u653e\u5165\u7684\u6700\u5927\u94fe\u63a5\u6570\n    */\n    if(err_log != 0)\n    {\n        perror("listen");\n        close(sockfd);      \n        exit(-1);\n    }   \n\n    printf("Waiting client...\\n");\n\n    while (1)\n    {\n        size_t recv_len = 0;\n        struct sockaddr_in client_addr;  //\u4fdd\u5b58\u5ba2\u6237\u7aef\u5730\u5740\n        char client_ip[INET_ADDRSTRLEN] = "";  //\u4fdd\u5b58\u5ba2\u6237\u7aefip\u5730\u5740\n        socklen_t cliaddr_len = sizeof(client_addr);  //\u521d\u59cb\u5316--\u5fc5\u987b\n\n        //\u83b7\u53d6\u5df2\u5efa\u7acb\u7684\u94fe\u63a5\n        connfd = accept(sockfd,(struct sockaddr*)&client_addr,&cliaddr_len);  //\u83b7\u5f97\u5df2\u5efa\u7acb\u7684\u94fe\u63a5\n        if(connfd < 0)\n        {\n            perror("accept");\n            continue;\n        }\n\n        inet_ntop(AF_INET,&client_addr.sin_addr,client_ip,INET_ADDRSTRLEN);\n        printf("client ip = %s\\n",client_ip);\n\n        //\u63a5\u6536\n        while ((recv_len = recv(connfd,recv_buf,sizeof(recv_buf),0)) > 0)\n        {\n            send(connfd,recv_buf,recv_len,0);\n        }\n\n        close(connfd);  //\u5173\u95ed\u5df2\u8fde\u63a5\u7684\u5957\u63a5\u5b57\n        printf("client closed!\\n");        \n    }\n\n    close(sockfd);\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"\u7ed3\u8bed"},"\u7ed3\u8bed"),(0,i.kt)("p",null,"~ ~ ~"))}_.isMDXComponent=!0}}]);